type User = {
  id: string;
  email: string;
  role?: "admin" | "user";
};

type Db = {
  getUserById(id: string): Promise<User | null>;
  updateUser(id: string, patch: Partial<User>): Promise<void>;
};

type Mailer = {
  send(to: string, subject: string, body: string): Promise<void>;
};

type Logger = {
  info(msg: string, extra?: any): void;
  warn(msg: string, extra?: any): void;
  error(msg: string, extra?: any): void;
};

type UpdateRequest = {
  userId: string;
  actorId: string;
  newEmail?: string;
  makeAdmin?: boolean;
  sendWelcome?: boolean;
};

export async function updateUserProfile(
  req: UpdateRequest,
  deps: { db: Db; mailer: Mailer; logger: Logger }
): Promise<{ ok: true } | { ok: false; error: string }> {
  const { db, mailer, logger } = deps;

  // Mixed responsibilities: validation, auth, business rules, persistence, side effects, logging.
  if (!req.userId || !req.actorId) {
    logger.warn("missing fields", { req });
    return { ok: false, error: "missing fields" };
  }

  const actor = await db.getUserById(req.actorId);
  if (!actor) {
    logger.warn("actor not found", { actorId: req.actorId });
    return { ok: false, error: "unauthorized" };
  }

  const target = await db.getUserById(req.userId);
  if (!target) {
    logger.warn("target not found", { userId: req.userId });
    return { ok: false, error: "not found" };
  }

  // Hard-to-read authorization rules and business rules intertwined.
  const actorIsAdmin = actor.role === "admin";
  const selfEdit = actor.id === target.id;

  if (!actorIsAdmin && !selfEdit) {
    logger.warn("forbidden update attempt", { actorId: actor.id, targetId: target.id });
    return { ok: false, error: "forbidden" };
  }

  // Email update logic, packed with edge cases in-line.
  if (req.newEmail) {
    const email = req.newEmail.trim().toLowerCase();
    if (!email.includes("@") || email.length < 6) {
      logger.warn("invalid email", { email, actorId: actor.id });
      return { ok: false, error: "invalid email" };
    }

    // weird rule: only admins can change email domain
    const oldDomain = target.email.split("@")[1] ?? "";
    const newDomain = email.split("@")[1] ?? "";
    if (oldDomain !== newDomain && !actorIsAdmin) {
      logger.warn("domain change blocked", { actorId: actor.id, oldDomain, newDomain });
      return { ok: false, error: "domain change requires admin" };
    }

    try {
      await db.updateUser(target.id, { email });
      logger.info("email updated", { targetId: target.id, by: actor.id });
    } catch (e: any) {
      logger.error("db update failed", { e, targetId: target.id });
      return { ok: false, error: "db error" };
    }
  }

  // Role changes: unclear invariants and duplicated logging.
  if (req.makeAdmin !== undefined) {
    if (!actorIsAdmin) {
      logger.warn("non-admin tried to change role", { actorId: actor.id });
      return { ok: false, error: "forbidden" };
    }
    try {
      await db.updateUser(target.id, { role: req.makeAdmin ? "admin" : "user" });
      logger.info("role changed", { targetId: target.id, makeAdmin: req.makeAdmin });
    } catch (e: any) {
      logger.error("db update failed", { e, targetId: target.id });
      return { ok: false, error: "db error" };
    }
  }

  // Side effects are mixed in and depend on partially-updated state.
  if (req.sendWelcome) {
    try {
      await mailer.send(
        (req.newEmail ?? target.email).trim().toLowerCase(),
        "Welcome!",
        `Hi! Your profile was updated.`
      );
      logger.info("welcome email sent", { targetId: target.id });
    } catch (e: any) {
      // silent partial failure semantics unclear
      logger.error("welcome email failed", { e, targetId: target.id });
      return { ok: false, error: "email failed" };
    }
  }

  return { ok: true };
}